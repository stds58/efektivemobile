input {
	beats { port => 5044 }
	tcp { port => 50000 }
	gelf { port => 5000 type => "gelf" }
	http { port => 8080 }
}

filter {
  # Если есть host — переименовываем,
  # чтобы не было конфликтов с полем host в кибане
  if [host] {
    mutate {
      rename => { "host" => "source_host" }
    }
  }

  # Для HTTP-запросов (FastAPI на Windows) → source_host приходит как объект → надо превратить в строку.
  # Для Beats/Filebeat → host приходит как строка → ты переименовываешь его в source_host → всё ок.
  if [source_host] {
    # Проверяем, является ли source_host объектом (а не строкой)
    ruby {
      code => "
        source_host = event.get('source_host')
        if source_host.is_a?(Hash) && source_host['ip']
          event.set('source_host', source_host['ip'])
        elsif source_host.is_a?(Hash)
          event.set('source_host', source_host.to_s)
        end
      "
    }
  }

  # Парсим JSON из message
  if [message] =~ /^{.*}$/ {
    json {
      source => "message"
      target => "parsed"
    }
    mutate {
      remove_field => ["message"]
    }
  }

  # Добавляем поля container_name и tag в случае,
  # если логи берём из ОС, а не из докера
  if ([url][domain] == "localhost" or [url][domain] == "127.0.0.1") and [url][port] == 8080 {
    mutate {
      add_field => {
        "tag" => "fastapi"
      }
      add_field => {
        "container_name" => "local"
      }
    }
  }

}


output {
  elasticsearch {
    hosts => ["http://elasticsearch:9200"]
    user => "logstash_internal"
    password => "${LOGSTASH_INTERNAL_PASSWORD}"
    ecs_compatibility => v8
    data_stream => true
  }
}
